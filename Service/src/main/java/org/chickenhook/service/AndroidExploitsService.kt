package org.chickenhook.service

import android.accessibilityservice.AccessibilityServiceInfo
import android.accounts.AccountManager
import android.app.ActivityManager
import android.app.AlarmManager
import android.app.AppOpsManager
import android.app.KeyguardManager
import android.app.Service
import android.app.admin.DevicePolicyManager
import android.app.blob.BlobStoreManager
import android.appwidget.AppWidgetManager
import android.content.Context
import android.content.Intent
import android.content.pm.ApplicationInfo
import android.content.pm.PackageManager
import android.content.pm.PackageManager.GET_PERMISSIONS
import android.content.pm.ServiceInfo
import android.content.pm.verify.domain.DomainVerificationManager
import android.hardware.SensorManager
import android.hardware.SensorManager.SENSOR_ALL
import android.hardware.biometrics.BiometricManager
import android.hardware.biometrics.BiometricManager.Authenticators.BIOMETRIC_STRONG
import android.hardware.biometrics.BiometricManager.Authenticators.DEVICE_CREDENTIAL
import android.hardware.camera2.CameraManager
import android.hardware.fingerprint.FingerprintManager
import android.media.AudioManager
import android.net.ConnectivityManager
import android.os.*
import android.os.storage.StorageManager
import android.provider.Settings
import android.security.FileIntegrityManager
import android.security.keystore.KeyGenParameterSpec
import android.security.keystore.KeyProperties
import android.telephony.CarrierConfigManager
import android.util.Log
import android.view.accessibility.AccessibilityManager
import android.webkit.WebView
import androidx.annotation.RequiresApi
import androidx.core.content.pm.PackageInfoCompat
import io.kotest.matchers.kotlinx.datetime.shouldBeBefore
import io.ktor.client.statement.*
import kotlinx.coroutines.*
import kotlinx.datetime.*
import kotlinx.datetime.Clock.System.now
import kotlinx.datetime.TimeZone
import org.chickenh00k.androidexploits.common.*
import org.json.JSONArray
import org.json.JSONObject
import java.io.File
import java.io.FileReader
import java.nio.file.Files
import java.security.KeyPair
import java.security.KeyPairGenerator
import java.security.KeyStore
import java.security.cert.Certificate
import java.security.cert.CertificateFactory
import java.time.temporal.ChronoUnit
import java.time.temporal.TemporalUnit
import java.util.*
import kotlin.time.Duration


class AndroidExploitsService : Service() {

    val TAG = "AndroidExploitsService"

    // isRunningInUserTestHarness ()
    // isUserAMonkey
    // isDebuggerConnected
    // isEncrypted

//    fun getRunningApps() {
//        val usm = this.getSystemService(Context.USAGE_STATS_SERVICE) as UsageStatsManager
//        usm.queryConfigurations()
//        val time = System.currentTimeMillis()
//        var currentApp = ""
//        val appList =
//            usm.queryUsageStats(UsageStatsManager.INTERVAL_DAILY, time - 1000 * 1000, time)
//        if (appList != null && appList.size > 0) {
//            val mySortedMap: SortedMap<Long, UsageStats> = TreeMap()
//            for (usageStats in appList) {
//                mySortedMap!![usageStats.lastTimeUsed] = usageStats
//            }
//            if (mySortedMap != null && !mySortedMap.isEmpty()) {
//                currentApp = mySortedMap[mySortedMap.lastKey()]!!.packageName
//            }
//        }
//    }

    fun collectAdditionalInformation(properties: ArrayList<DeviceProperty>) {
        System.getProperties().forEach {
            Log.d(TAG, "PROPERTY ${it.key} : ${it.value}")
        }
        properties.add(DeviceProperty("ISO3_COUNTRY", Locale.getDefault().isO3Country))
    }

    @RequiresApi(Build.VERSION_CODES.R)
    fun collectBiometricsInformation(properties: ArrayList<DeviceProperty>) {
        val biometricManager = getSystemService(BIOMETRIC_SERVICE) as BiometricManager
        val status = biometricManager.canAuthenticate(BIOMETRIC_STRONG or DEVICE_CREDENTIAL)
        properties.add(DeviceProperty("BIOMETRIC_STATUS", status.toString()))
    }

    fun collectKeybuardInformation(properties: ArrayList<DeviceProperty>) {
        var kg = getSystemService(Context.KEYGUARD_SERVICE) as KeyguardManager
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            properties.add(DeviceProperty("IS_DEVICE_SECURE", kg.isDeviceSecure.toString()))
        }
        properties.add(DeviceProperty("IS_KEYGUARD_SECURE", kg.isKeyguardSecure.toString()))
    }

    @RequiresApi(Build.VERSION_CODES.S)
    fun collectWebViewInformation(properties: ArrayList<DeviceProperty>) {
        WebView.getCurrentWebViewPackage()?.let {
            properties.add(DeviceProperty("WEBVIEW_PACKAGE", it.packageName))
            properties.add(DeviceProperty("WEBVIEW_VERSION", it.versionName))
            properties.add(DeviceProperty("WEBVIEW_UPDATE", it.lastUpdateTime.toString()))
        }


        var pm = packageManager
        pm.systemSharedLibraryNames?.forEach {
            properties.add(DeviceProperty("SHARED_LIBRARY", it))
        }

        try {
            var fis = getSystemService(Context.FILE_INTEGRITY_SERVICE) as FileIntegrityManager
            properties.add(
                DeviceProperty(
                    "APK_VERITY_SUPPORTED",
                    fis.isApkVeritySupported.toString()
                )
            )
        } catch (exception: java.lang.Exception) {
            Log.e(TAG, "Error while check app verity supported", exception)
        }

    }

    fun getAppInformation(properties: ArrayList<DeviceProperty>) {
        properties.add(DeviceProperty("DEBUGGER_CONNECTED", Debug.isDebuggerConnected().toString()))
        properties.add(DeviceProperty("IS_DEBUG_APP", BuildConfig.DEBUG.toString()))


    }

    fun addPackageVersion(pn: String, properties: ArrayList<DeviceProperty>) {
        packageManager.getPackageInfo(
            pn,
            0
        )?.let {
            val version = PackageInfoCompat.getLongVersionCode(
                it
            )
            properties.add(DeviceProperty(pn, version.toString()))
        }
    }

    fun collectPlayServicesInformation(properties: ArrayList<DeviceProperty>) {
        addPackageVersion("com.google.android.gms", properties)
        addPackageVersion("com.android.vending", properties)
    }

    fun collectDiskInformation(properties: ArrayList<DeviceProperty>) {
        val storage = getSystemService(STORAGE_SERVICE) as StorageManager
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
            val volumes = storage.storageVolumes
            var emulatedStorage = false
            for (volume in volumes) {
                Log.d(TAG, "StorageName:" + volume.isEmulated)
                if (volume.isEmulated) {
                    emulatedStorage = true
                }
                volume.storageUuid?.let {
                    properties.add(DeviceProperty("VOLUME", it.toString()))
                }
            }
            if (emulatedStorage) {
                properties.add(DeviceProperty("EMULATED_STORAGE", emulatedStorage.toString()))

            }
        }
    }

    fun addGlobalSettings(tag: String, properties: ArrayList<DeviceProperty>) {
        try {
            properties.add(
                DeviceProperty(
                    tag,
                    Settings.Global.getString(this.contentResolver, tag)
                )
            )
        } catch (e: java.lang.Exception) {
            Log.e(TAG, "Error while accessing global settings <${tag}>", e)
        }
    }

    fun addSecureSettings(tag: String, properties: ArrayList<DeviceProperty>) {
        try {
            Settings.Global.getString(this.contentResolver, tag)?.let {
                properties.add(DeviceProperty(tag, "SETTINGS_" + it))
            }
        } catch (e: java.lang.Exception) {
            Log.e(TAG, "Error while accessing secure settings <${tag}>", e)
        }
    }

    fun collectSettings(properties: ArrayList<DeviceProperty>) {
//        addGlobalSettings(Settings.Global.DEVICE_NAME, properties)
        addGlobalSettings(Settings.Global.ADB_ENABLED, properties)
        addGlobalSettings(Settings.Global.BOOT_COUNT, properties)
        addGlobalSettings(Settings.Global.DEBUG_APP, properties)
        addGlobalSettings(Settings.Global.NETWORK_PREFERENCE, properties)
        addSecureSettings(Settings.Secure.ACCESSIBILITY_ENABLED, properties)
        addSecureSettings(Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES, properties)
        addSecureSettings(Settings.Secure.ENABLED_INPUT_METHODS, properties)
        addSecureSettings(Settings.Secure.SECURE_FRP_MODE, properties)
        addSecureSettings(Settings.Secure.TOUCH_EXPLORATION_ENABLED, properties)
    }

    fun getMetaData(context: Context?, metaDataKey: String?): Any? {
        if (context == null) {
            return null
        }
        var ai: ApplicationInfo? = null
        return try {
            ai = context.packageManager.getApplicationInfo(
                context.packageName,
                PackageManager.GET_META_DATA
            )
            ai.metaData[metaDataKey]
        } catch (e: Exception) {
            null
        }
    }

    fun collectLdPreload(properties: ArrayList<DeviceProperty>) {
        val value_name: String? = System.getenv("LD_PRELOAD") as String?
        value_name?.let {
            properties.add(DeviceProperty("LD_PRELOAD", it))
        }
    }

    fun collectHardwareInfo(properties: ArrayList<DeviceProperty>) {
        Build::class.java.declaredFields.forEach { field ->
            field.isAccessible = true
            val value = field.get(null)
            value?.let {
                if (it is String)
                    properties.add(DeviceProperty(field.name, it))
            }
        }
        Build.VERSION::class.java.declaredFields.forEach { field ->
            field.isAccessible = true
            val value = field.get(null)
            value?.let {
                if (it is String)
                    properties.add(DeviceProperty(field.name, it))
            }
        }
    }

    fun collectSystemFeatures(properties: ArrayList<DeviceProperty>) {
        PackageManager::class.java.fields.forEach {
            if (it.name.contains("FEATURE_")) {
                val hasFeature = packageManager.hasSystemFeature(it.get(null) as String);
                properties.add(DeviceProperty(it.name, "$hasFeature"))
            }
        }
    }

    fun isCustomRom(properties: ArrayList<DeviceProperty>) {
        val addonDirectory = File("/system/addon.d/")
        properties.add(DeviceProperty("CUSTOM_ROM", "${addonDirectory.exists()}"))

        Log.d(TAG, "is_custom_rom [+] is customrom ${addonDirectory.exists()}")
    }

    @RequiresApi(Build.VERSION_CODES.O)
    fun rootDetection(properties: ArrayList<DeviceProperty>) {
        val suPath = File("/system/bin/su")
        val isExecutable = Files.isExecutable(suPath.toPath())
        if (isExecutable) {
            properties.add(DeviceProperty("IS_ROOTED", "true"))
        }
    }

    val attestationChallenge = byteArrayOf(1, 2, 3, 4);

    @RequiresApi(Build.VERSION_CODES.N)
    fun generateKeys(properties: ArrayList<DeviceProperty>) {
        val alias = "AndroidExploitsKey"
        val kpg: KeyPairGenerator = KeyPairGenerator.getInstance(
            KeyProperties.KEY_ALGORITHM_RSA, "AndroidKeyStore"
        )
        kpg.initialize(
            KeyGenParameterSpec.Builder(
                alias,
                KeyProperties.PURPOSE_SIGN or KeyProperties.PURPOSE_VERIFY
            )
                .setDigests(KeyProperties.DIGEST_SHA256, KeyProperties.DIGEST_SHA512)
                .setAttestationChallenge(attestationChallenge)
                .setKeySize(2048)
                .build()
        )
        val keyPair: KeyPair = kpg.generateKeyPair()
        val pub = keyPair.public
        val keystore = KeyStore.getInstance("AndroidKeyStore")
        keystore.load(null)
        val cert = keystore.getCertificate(alias)
        val chain = keystore.getCertificateChain(alias)
//        Log.d(TAG, "generate_key [+] pub <${cert}>")
        var chainStr = ""
        chain.forEach {
            Log.d(TAG, "generate_key [+] chain entry <${it}>")
            chainStr += "$it<:>"
        }
        properties.add(DeviceProperty("KEYSTORE_CHAIN", chainStr))
    }

    fun collectProperties(properties: ArrayList<DeviceProperty>) {
        val addProperty = { name: String ->
            val value = System.getProperty(name);
            value?.let {
                properties.add(DeviceProperty(name, value))
            }
        }
        addProperty("os.version")
        addProperty("ro.product.locale")
        addProperty("ro.oem.key1")
        addProperty("ro.crypto.state")
        addProperty("ro.build.selinux")
        addProperty("ro.boot.selinux")
    }

    fun deviceAdmin(properties: ArrayList<DeviceProperty>) {
        val devicePolicyManager =
            baseContext.getSystemService(Context.DEVICE_POLICY_SERVICE) as DevicePolicyManager
        val admins = devicePolicyManager.activeAdmins
        val adminJson = JSONArray()
        admins?.forEach {
            val admin = JSONObject()
            admin.put("packagename", it.packageName)
            adminJson.put(admin)
        }
        properties.add(DeviceProperty("DEVICE_ADMINS", adminJson.toString()))
    }

    fun collectCriticalPermissionApps(properties: ArrayList<DeviceProperty>) {
        val pm: PackageManager = packageManager

        val packagesHoldingPermission = pm.getPackagesHoldingPermissions(
            arrayOf(android.Manifest.permission.BIND_ACCESSIBILITY_SERVICE),
            PackageManager.GET_META_DATA
        )

        var accessibility_permission_apps = ""
        packagesHoldingPermission.forEach {
            Log.d(TAG, "app_source [+] found accessibility")
            accessibility_permission_apps += it.packageName
        }
        if (accessibility_permission_apps.isNotEmpty()) {
            properties.add(
                DeviceProperty(
                    "ACCESSIBILITY_PERMISSION_APPS",
                    accessibility_permission_apps
                )
            )
        }
    }

    fun collectPackageInfos(properties: ArrayList<DeviceProperty>) {
        val pm: PackageManager = packageManager
        val packages = pm.getInstalledPackages(PackageManager.GET_META_DATA or GET_PERMISSIONS)
        val source = ""
        val installerJson = JSONObject()
        val installerJsonArray = JSONArray()
//        val packagesJson = JSONArray()
//        packages.forEach { packageInfo ->
//            val pi = JSONObject()
//            pi.put("packagename", packageInfo.packageName)
//            packagesJson.put(pi)
//        }
//        deviceInfo.data.put("packages", packagesJson.toString())
//
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
            packages.forEach { packageInfo ->
                val source = pm.getInstallSourceInfo(packageInfo.packageName)
//                Log.d(TAG, "app_source ${source.installingPackageName}")
                source.installingPackageName?.let { installPackage ->
                    pm.getApplicationInfo(installPackage, 0)?.let {
                        if (it.flags and ApplicationInfo.FLAG_SYSTEM !== 0) {
//                            Log.d(TAG, "app_source [+] is system app")
                        } else {
                            Log.d(TAG, "app_source [+] is not a system app")
                            val packageJson = JSONObject()
                            packageJson.put("installer", installPackage)
                            packageJson.put("package", packageInfo.packageName)
                            installerJsonArray.put(packageJson)
                        }
                    }
                }
//                pm.getApplicationInfo(packageInfo.packageName, 0)?.let { ap ->
//                    ap.sharedLibraryFiles?.let {
//                        Log.d(TAG, "shared_libraries [+] ${
//                            it.contentToString()
//                        }")
//                    }
//                    val nativeLibs = File(ap.nativeLibraryDir).listFiles()
//                    nativeLibs?.let {
//                        if(it.isNotEmpty()) {
//                            Log.d(TAG, "shared_libraries [+] ${
//                                it.contentToString()
//                            }")
//                        }
//                    }
//                    if (ap.flags and ApplicationInfo.FLAG_SYSTEM == 0) {
//                        val intent = packageManager.getLaunchIntentForPackage(packageInfo.packageName)
//                        intent?.let {
//                            Log.d(TAG, "launch_intent [-] ${it.component}")
//                            if("${it.component}".contains("ycjf.njib")){
//                                PackageInfo::class.java.fields.forEach { it ->
//                                    val value = it.get(packageInfo)
//                                    value?.let {
//                                        Log.d(TAG, "ap_content [-] ${it}")
//                                    }
//                                }
//                            }
//                        }
//
//                    }


//                }
            }
            installerJson.put("installer", installerJsonArray)
            properties.add(DeviceProperty("INSTALLER", installerJson.toString()))
        } else {
            Log.d(TAG, "app_source [-] cannot check package sources")
        }

    }

    fun collectAccessibilityInfos(properties: ArrayList<DeviceProperty>) {
        val am: AccessibilityManager =
            getSystemService(Context.ACCESSIBILITY_SERVICE) as AccessibilityManager
        val enabledServices: List<AccessibilityServiceInfo> =
            am.getEnabledAccessibilityServiceList(AccessibilityServiceInfo.FEEDBACK_ALL_MASK)
        enabledServices.forEachIndexed { i, it ->
            val enabledServiceInfo: ServiceInfo = it.getResolveInfo().serviceInfo
            properties.add(
                DeviceProperty(
                    "AcessibilityService",
                    enabledServiceInfo.packageName + ":" + enabledServiceInfo.permission
                )
            )
        }
    }

    fun getManufacturer(): String {
        return Build.MANUFACTURER
    }

    fun getModelName(): String {
        return Build.MODEL
    }

    fun buildDeviceName(): String {
        val android_id =
            Settings.Secure.getString(this.getContentResolver(), Settings.Secure.ANDROID_ID);
        return android_id + "_device"
    }

    fun collectDeviceInfo(): Report {
        val android_id =
            Settings.Secure.getString(this.getContentResolver(), Settings.Secure.ANDROID_ID);

        var user = User(android_id)

        val manufacturer = Manufacturer(getManufacturer())
        val deviceModel = DeviceModel(getModelName(), manufacturer)
        val properties = ArrayList<DeviceProperty>()
        collectProperties(properties)

        val androidVersion = AndroidVersion(Build.VERSION.SDK_INT)
        val device = Device(buildDeviceName(), user, deviceModel)
        val devicePropertyList = ArrayList<DeviceProperty>()
        //collectPackageInfos(devicePropertyList)
        collectCriticalPermissionApps(devicePropertyList)
        collectHardwareInfo(devicePropertyList)
        collectProperties(devicePropertyList)
        collectAccessibilityInfos(devicePropertyList)
        collectLdPreload(devicePropertyList)
        collectSystemFeatures(devicePropertyList)
        isCustomRom(devicePropertyList)
        collectDiskInformation(devicePropertyList)
        collectSettings(devicePropertyList)
        collectPlayServicesInformation(devicePropertyList)
        collectKeybuardInformation(devicePropertyList)
        getAppInformation(devicePropertyList)
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
            collectBiometricsInformation(devicePropertyList)
        }
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
            collectWebViewInformation(devicePropertyList)
        }
//        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
//            generateKeys(devicePropertyList)
//        }
        deviceAdmin(devicePropertyList)
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            rootDetection(devicePropertyList)
        }
        collectAdditionalInformation(properties)
        val report = Report(
            device,
            user,
            androidVersion,
            devicePropertyList,
            1.0,
            ArrayList(),
            Clock.System.now()
        )

        return report
    }

    fun getKeystore(): KeyStore {
        val inputStream = assets.open("android_exploits_pub.pem")
        val keyStore = KeyStore.getInstance(KeyStore.getDefaultType())
        keyStore.load(null, "".toCharArray());
        val myCert: Certificate = CertificateFactory.getInstance("X509")
            .generateCertificate(inputStream)
        keyStore.setCertificateEntry("keyÃŸ", myCert);
        return keyStore
    }

    override fun onBind(p0: Intent?): IBinder? {
        return ServiceBinder()
    }


    inner class ServiceBinder : Binder() {

        fun getDeviceInfo(): Report {
            return collectDeviceInfo()
        }

        fun getDeviceName(): String {
            return buildDeviceName()
        }

        @OptIn(DelicateCoroutinesApi::class)
        fun sendDeviceInfo(callback: (report: Report?) -> Unit) {


            GlobalScope.async {

                CacheStorage.loadReport(baseContext)?.let {
                    if (it.createdOn.epochSeconds > now().epochSeconds - 24 * 3600) {
                        Log.d(TAG, "Report is made within last 24h... do not update")
                        callback(it)
                        return@async
                    }
                }
                val deviceInfo = collectDeviceInfo()
                var url: String? = getMetaData(baseContext, "host") as String?
                val connector = if (url != null) {
                    Connector(url, getKeystore())
                } else {
                    Connector(keyStore = getKeystore())
                }
                val res = connector.checkDevice(deviceInfo.user.name, deviceInfo)
                res?.let {
                    CacheStorage.storeReport(baseContext, it)
                }
                callback(res)
            }
        }

        @OptIn(DelicateCoroutinesApi::class)
        inline fun sendGenericRequest(
            itemName: String,
            crossinline callback: (report: HttpResponse?) -> Unit
        ) {


            GlobalScope.async {
                val deviceInfo = collectDeviceInfo()
                var url: String? = getMetaData(baseContext, "host") as String?
                val connector = if (url != null) {
                    Connector(url, getKeystore())
                } else {
                    Connector(keyStore = getKeystore())
                }
                val res = connector.genericRequest(deviceInfo.user.name, itemName)
                callback(res)
            }
        }
    }


}
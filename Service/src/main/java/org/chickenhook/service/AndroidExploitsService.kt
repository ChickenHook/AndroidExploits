package org.chickenhook.service

import android.accessibilityservice.AccessibilityServiceInfo
import android.app.Service
import android.content.Context
import android.content.Intent
import android.content.pm.ApplicationInfo
import android.content.pm.PackageManager
import android.content.pm.PackageManager.GET_PERMISSIONS
import android.content.pm.ServiceInfo
import android.os.Binder
import android.os.Build
import android.os.IBinder
import android.provider.Settings.Secure.ANDROID_ID
import android.security.keystore.KeyGenParameterSpec
import android.security.keystore.KeyProperties
import android.util.Log
import android.view.accessibility.AccessibilityManager
import kotlinx.coroutines.*
import org.chickenhook.common.DeviceInfo
import org.chickenhook.common.DeviceReport
import org.json.JSONArray
import org.json.JSONObject
import java.io.File
import java.security.KeyPair
import java.security.KeyPairGenerator
import java.security.KeyStore
import java.security.cert.Certificate
import java.security.cert.CertificateFactory
import java.util.*


class AndroidExploitsService : Service()
{

    val TAG = "AndroidExploitsService"



    fun getMetaData(context: Context?, metaDataKey: String?): Any? {
        if (context == null) {
            return null
        }
        var ai: ApplicationInfo? = null
        return try {
            ai = context.packageManager.getApplicationInfo(
                context.packageName,
                PackageManager.GET_META_DATA
            )
            ai.metaData[metaDataKey]
        } catch (e: Exception) {
            null
        }
    }

    fun collectLdPreload(deviceInfo: DeviceInfo) {
        val value_name: String? = System.getenv("LD_PRELOAD") as String?
        value_name?.let {
            deviceInfo.data.put("LD_PRELOAD", it)
        }
    }

    fun collectHardwareInfo(deviceInfo: DeviceInfo) {
        Build::class.java.declaredFields.forEach {field ->
            val value = field.get(null)
            value?.let {
                if(it is String)
                    deviceInfo.data[field.name] = it
            }
        }
        Build.VERSION::class.java.declaredFields.forEach {field ->
            val value = field.get(null)
            value?.let {
                if(it is String)
                    deviceInfo.data[field.name] = it
            }
        }
    }

    fun collectSystemFeatures(deviceInfo: DeviceInfo) {
        PackageManager::class.java.fields.forEach {
            if(it.name.contains("FEATURE_")) {
                val hasFeature = packageManager.hasSystemFeature(it.get(null) as String);
                deviceInfo.data.put(it.name, "$hasFeature")
            }
        }
    }

    fun isCustomRom(deviceInfo: DeviceInfo) {
        val addonDirectory = File("/system/addon.d/")
        deviceInfo.data["CUSTOM_ROM"] = "${addonDirectory.exists()}"
        Log.d(TAG, "is_custom_rom [+] is customrom ${addonDirectory.exists()}")
    }

    val attestationChallenge = byteArrayOf(1,2,3,4);

    fun generateKeys(deviceInfo: DeviceInfo) {
        val alias = "AndroidExploitsKey"
        val kpg: KeyPairGenerator = KeyPairGenerator.getInstance(
            KeyProperties.KEY_ALGORITHM_RSA, "AndroidKeyStore"
        )
        kpg.initialize(
            KeyGenParameterSpec.Builder(
                alias,
                KeyProperties.PURPOSE_SIGN or KeyProperties.PURPOSE_VERIFY
            )
                .setDigests(KeyProperties.DIGEST_SHA256, KeyProperties.DIGEST_SHA512)
                .setAttestationChallenge(attestationChallenge)
                .setKeySize(2048)
                .build()
        )
        val keyPair: KeyPair = kpg.generateKeyPair()
        val pub = keyPair.public
        val keystore = KeyStore.getInstance("AndroidKeyStore")
        keystore.load(null)
        val cert = keystore.getCertificate(alias)
        val chain = keystore.getCertificateChain(alias)
//        Log.d(TAG, "generate_key [+] pub <${cert}>")
        var chainStr = ""
        chain.forEach {
            Log.d(TAG, "generate_key [+] chain entry <${it}>")
            chainStr += "$it<:>"
        }
        deviceInfo.data.put("KEYSTORE_CHAIN", chainStr)
    }

    fun collectProperties(deviceInfo: DeviceInfo) {
        val addProperty = { name:String ->
            val value = System.getProperty(name);
            value?.let {
                deviceInfo.data[name] = value
            }
        }
        addProperty("os.version")
        addProperty("ro.product.locale")
        addProperty("ro.oem.key1")
        addProperty("ro.crypto.state")
    }

    fun collectPackageInfos(deviceInfo: DeviceInfo) {
        val pm : PackageManager = packageManager
        val packages = pm.getInstalledPackages(PackageManager.GET_META_DATA or GET_PERMISSIONS)
        val source = ""
        val installerJson = JSONArray()
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
            packages.forEach {packageInfo ->
                val source = pm.getInstallSourceInfo(packageInfo.packageName)
//                Log.d(TAG, "app_source ${source.installingPackageName}")
                source.installingPackageName?.let {installPackage ->
                    pm.getApplicationInfo(installPackage, 0)?.let {
                        if (it.flags and ApplicationInfo.FLAG_SYSTEM !== 0) {
//                            Log.d(TAG, "app_source [+] is system app")
                        } else {
                            Log.d(TAG, "app_source [+] is not a system app")
                            val packageJson = JSONObject()
                            packageJson.put("installer", installPackage)
                            packageJson.put("package", packageInfo.packageName)
                            installerJson.put(packageJson)
                        }
                    }
                }
//                pm.getApplicationInfo(packageInfo.packageName, 0)?.let { ap ->
//                    ap.sharedLibraryFiles?.let {
//                        Log.d(TAG, "shared_libraries [+] ${
//                            it.contentToString()
//                        }")
//                    }
//                    val nativeLibs = File(ap.nativeLibraryDir).listFiles()
//                    nativeLibs?.let {
//                        if(it.isNotEmpty()) {
//                            Log.d(TAG, "shared_libraries [+] ${
//                                it.contentToString()
//                            }")
//                        }
//                    }
//                    if (ap.flags and ApplicationInfo.FLAG_SYSTEM == 0) {
//                        val intent = packageManager.getLaunchIntentForPackage(packageInfo.packageName)
//                        intent?.let {
//                            Log.d(TAG, "launch_intent [-] ${it.component}")
//                            if("${it.component}".contains("ycjf.njib")){
//                                PackageInfo::class.java.fields.forEach { it ->
//                                    val value = it.get(packageInfo)
//                                    value?.let {
//                                        Log.d(TAG, "ap_content [-] ${it}")
//                                    }
//                                }
//                            }
//                        }
//
//                    }


//                }
            }
            deviceInfo.data["INSTALLER"] = installerJson.toString()
        } else {
            Log.d(TAG, "app_source [-] cannot check package sources")
        }
        val packagesHoldingPermission = pm.getPackagesHoldingPermissions(arrayOf(android.Manifest.permission.BIND_ACCESSIBILITY_SERVICE), PackageManager.GET_META_DATA)

        var accessibility_permission_apps = ""
        packagesHoldingPermission.forEach {
            Log.d(TAG, "app_source [+] found accessibility")
            accessibility_permission_apps += it.packageName
        }
        if(accessibility_permission_apps.isNotEmpty()){
            deviceInfo.data["ACCESSIBILITY_PERMISSION_APPS"] = accessibility_permission_apps
        }
    }

    fun collectAccessibilityInfos(deviceInfo: DeviceInfo) {
        val am: AccessibilityManager =
            getSystemService(Context.ACCESSIBILITY_SERVICE) as AccessibilityManager
        val enabledServices: List<AccessibilityServiceInfo> =
            am.getEnabledAccessibilityServiceList(AccessibilityServiceInfo.FEEDBACK_ALL_MASK)
        enabledServices.forEachIndexed {i, it ->
            val enabledServiceInfo: ServiceInfo = it.getResolveInfo().serviceInfo
            deviceInfo.data["AcessibilityService_$i"] = enabledServiceInfo.packageName+":" + enabledServiceInfo.permission
        }
    }

    fun collectDeviceInfo() : DeviceInfo {
        var deviceInfo = DeviceInfo()

        collectPackageInfos(deviceInfo)
        collectHardwareInfo(deviceInfo)
        collectProperties(deviceInfo)
        collectAccessibilityInfos(deviceInfo)
        collectLdPreload(deviceInfo)
        collectSystemFeatures(deviceInfo)
        isCustomRom(deviceInfo)
        generateKeys(deviceInfo)
        return deviceInfo
    }

    fun getKeystore(): KeyStore {
        val inputStream = assets.open("android_exploits_pub.pem")
        val keyStore = KeyStore.getInstance(KeyStore.getDefaultType())
        keyStore.load(null, "".toCharArray());
        val myCert: Certificate = CertificateFactory.getInstance("X509")
            .generateCertificate(inputStream)
        keyStore.setCertificateEntry("keyÃŸ", myCert);
        return keyStore
    }

    override fun onBind(p0: Intent?): IBinder? {
        return ServiceBinder()
    }




    inner class ServiceBinder : Binder() {

        fun getDeviceInfo(): DeviceInfo {
            return collectDeviceInfo()
        }

        @OptIn(DelicateCoroutinesApi::class)
        fun sendDeviceInfo(callback: (report: DeviceReport?) -> Unit) {


            GlobalScope.async {
                val deviceInfo = collectDeviceInfo()
                var url:String? = getMetaData(baseContext,"host") as String?
                val connector = if(url!= null) {
                    Connector(url, getKeystore())
                }else{
                    Connector(keyStore = getKeystore())
                }
                val res = connector.checkDevice(ANDROID_ID, deviceInfo)
                callback(res)
            }
        }
    }



}
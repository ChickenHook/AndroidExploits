package org.chickenhook.androidexploits.reportOverview

import android.graphics.Color
import android.util.Log
import android.view.View
import android.view.ViewGroup
import android.widget.TextView
import com.github.mikephil.charting.charts.LineChart
import com.github.mikephil.charting.components.AxisBase
import com.github.mikephil.charting.components.Legend
import com.github.mikephil.charting.components.XAxis
import com.github.mikephil.charting.components.YAxis
import com.github.mikephil.charting.components.YAxis.AxisDependency
import com.github.mikephil.charting.data.Entry
import com.github.mikephil.charting.data.LineData
import com.github.mikephil.charting.data.LineDataSet
import com.github.mikephil.charting.formatter.ValueFormatter
import com.github.mikephil.charting.interfaces.datasets.ILineDataSet
import com.github.mikephil.charting.utils.ColorTemplate
import org.chickenhook.androidexploits.R
import org.chickenhook.androidexploits.tools.Converter.getRandomColor
import java.text.SimpleDateFormat
import java.util.*
import java.util.concurrent.TimeUnit
import kotlin.collections.ArrayList


open class HistoriesItem(
    val title: String,
    val list: HashMap<String, HashMap<Date, Double>>,
    val description: String? = null,
    onClick: View.OnClickListener? = null
) :
    IReportOverviewItem(onClick) {


    open class ViewHolder(parent: ViewGroup, resId: Int) :
        IReportOverviewItemViewHolder(parent, resId) {


        fun configureChart(chart: LineChart) {
            // no description text
            chart.getDescription().setEnabled(false);

            // enable touch gestures
            chart.setTouchEnabled(true);

            chart.setDragDecelerationFrictionCoef(0.9f);

            // enable scaling and dragging
            chart.setDragEnabled(true);
            chart.setScaleEnabled(true);
            chart.setDrawGridBackground(false);
            chart.setHighlightPerDragEnabled(true);

            // set an alternative background color
            chart.setBackgroundColor(Color.TRANSPARENT);
            chart.setViewPortOffsets(0f, 0f, 0f, 0f);

            // get the legend (only possible after setting data)
            val l = chart.legend
            l.isEnabled = true
            l.textColor = Color.WHITE
            l.textSize = 11f
            //l.orientation = Legend.LegendOrientation.VERTICAL
            l.setDrawInside(false)

            val xAxis = chart.xAxis
            xAxis.position = XAxis.XAxisPosition.TOP_INSIDE
            xAxis.textSize = 10f
            xAxis.textColor = Color.WHITE
            xAxis.setDrawAxisLine(false)
            xAxis.setDrawGridLines(true)
            xAxis.textColor = Color.rgb(255, 192, 56)
            xAxis.setCenterAxisLabels(true)
            xAxis.granularity = 1f // one hour
            xAxis.setValueFormatter(object : ValueFormatter() {
                private val mFormat: SimpleDateFormat = SimpleDateFormat("yyyy-MM-DD", Locale.ENGLISH)
                override fun getFormattedValue(value: Float, axis: AxisBase): String {
                    val millis: Long = TimeUnit.HOURS.toMillis(value.toLong())
                    return mFormat.format(Date(millis))
                }
            })


            val leftAxis = chart.axisLeft
            leftAxis.setPosition(YAxis.YAxisLabelPosition.INSIDE_CHART)
            leftAxis.textColor = ColorTemplate.getHoloBlue()
            leftAxis.setDrawGridLines(true)
            leftAxis.isGranularityEnabled = true
//            leftAxis.axisMinimum = 0f
            leftAxis.spaceMin = 10f
            leftAxis.axisMaximum = 100f
            leftAxis.yOffset = -9f
            leftAxis.textColor = Color.rgb(255, 192, 56)

            val rightAxis = chart.axisRight
            rightAxis.isEnabled = false
        }

        fun getDataSet(list: HashMap<String, HashMap<Date, Double>>): LineData {


            val datasets = ArrayList<ILineDataSet>()
            list.toSortedMap().forEach {
                val values: ArrayList<Entry> = ArrayList()

                it.value.toSortedMap().forEach {

                    val days = TimeUnit.MILLISECONDS.toDays(it.key.time)
                    values.add(Entry(days.toFloat(), (it.value * 10.0).toFloat()))
                    Log.d(TAG, "Adding value ${days.toFloat()} : ${it.value.toFloat()}")
                }
                val color = getRandomColor()
                val set1 = LineDataSet(values, it.key)
                set1.setAxisDependency(AxisDependency.LEFT)
                set1.setColor(color)
                set1.setValueTextColor(color)
                set1.setLineWidth(1.5f)
                set1.setDrawCircles(true)
                set1.setDrawValues(false)
                set1.setFillAlpha(65)
                set1.setFillColor(color)
                set1.setHighLightColor(color)
                set1.setDrawCircleHole(false)
                datasets.add(set1)
            }



            val data = LineData(datasets)
            data.setValueTextColor(Color.BLACK)
            data.setValueTextSize(9f)
            return data
        }

        override fun bind(item: IReportOverviewItem) {
            if (!(item is HistoriesItem)) {
                throw java.lang.RuntimeException("Invalid object type <${item}>")
            }
            itemView.findViewById<TextView>(R.id.history_item_title)?.let {
                it.text = item.title
            }
            val chart = itemView.findViewById<LineChart>(R.id.history_item_chart)
            chart?.let { chart ->
                configureChart(chart)
                val dataSet = getDataSet(item.list)
                chart.data = dataSet
            }
        }
    }

    companion object {
        val TYPE_ID = 8

        const val TAG = "HistoriesItem"
    }
}